#!/usr/bin/env python3
from ev3dev.ev3 import *
from math import pi

mR = LargeMotor("outA")
mL = LargeMotor("outD")
gyro = GyroSensor("in2")
ts = TouchSensor("in3")


def U_satur(U,lowerLimit,upperLimit):
    if U>upperLimit:
        U = upperLimit
    if U<lowerLimit:
        U = lowerLimit
    return U


#K = [-128.3034298538849, -4.398481779210177, -14.481407447874158]   #0.3
#K = [-156.29503070806675, -5.855146473539337, -18.383719362039976]  #0.27
#K = [-211.99416682224827, -9.175570645078881, -26.937759150460533]  #0.23
#K = [-252.5067629673386, -11.904145128892642, -33.77064045255656]   #0.21
#K = [-277.4691975636699, -13.704876004834341, -38.220052443019185]  #0.2
#K = [-306.47594796042046, -15.904844443603254, -43.608673011134925] #0.19
#K =  [-535.5272859917723, -28.71272799795627, -93.26663932967264]   #0.16
#K = [-607.8952982875267, -34.74407522359375, -111.23071132237423]   #0,15
#K = [-486.30127235736916, -31.82785423368141, -81.7562269636138]    #0.15
#K = [-696.3186233835897, -42.62331409607465, -134.55321354092143]   #0.14
#K = [-805.923132658959, -53.11598264889798, -165.43070387991162]    #0.13
#K = [-500, -3, -100]
#K = [-1670.3303461850533, -159.10997788700806, -472.7968759145291]  #0.09 большие коэфы
#K = [-2754.4477419988552, -337.6265127685971, -984.9533030555817]   #0.07
#K = [-33626.3845212279, -14455.636734953609, -41029.29754931585]    #0.02


#K = [-323.25275003034704, -10.26068366760085, -52.73320722900388] # 0.25
#K = [-1164.861344764976, -70.03993732647396, -310.81171354997923] # 0.13



K = [-200,-0.5,-4]
print(K)




u = 0
DEG0 = gyro.rate_and_angle[0]*pi/180



def angle():
    global DEG0, gyro, ANGLE_S
    return (gyro.rate_and_angle[0]*pi/180 - DEG0 )



while True :  
    # print(gyro.angle)
    X =  [angle(), mR.speed * pi / 180, gyro.rate_and_angle[1]*pi/180]
    u = -(K[0]*X[0] + K[1]*X[1] + K[2]*X[2])
    UU = U_satur(u,-100,100)
    #print(UU, X)

    #print( u, X[0]*180/pi, X[1]*180/pi, X[2]*180/pi)

    if ts.is_pressed:
        mR.run_direct(duty_cycle_sp = 0)
        mL.run_direct(duty_cycle_sp = 0)
        DEG0 = gyro.rate_and_angle[0]*pi/180
    else:
    	mR.run_direct(duty_cycle_sp = UU)
    	mL.run_direct(duty_cycle_sp = UU)


mR.run_direct(duty_cycle_sp = 0)
mL.run_direct(duty_cycle_sp = 0)